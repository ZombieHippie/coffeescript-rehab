// Generated by CoffeeScript 1.7.1
(function() {
  var Rehab, deppy, fs, p, wrench,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  wrench = require('wrench');

  fs = require('fs');

  p = require('path');

  deppy = require('deppy');

  String.prototype.endsWith = function(str) {
    return this.match(RegExp("" + str + "$")) != null;
  };

  String.prototype.getDir = function() {
    if (this.endsWith('.coffee')) {
      return p.dirname(this);
    } else {
      return this.toString();
    }
  };

  module.exports = Rehab = (function() {
    function Rehab(path) {
      var sourceFolder, sources, toResolve;
      if (path == null) {
        path = null;
      }
      this.parseRequiredFile = __bind(this.parseRequiredFile, this);
      this.parseFile = __bind(this.parseFile, this);
      this.processDependencies = __bind(this.processDependencies, this);
      this.compile = __bind(this.compile, this);
      this.listFiles = __bind(this.listFiles, this);
      if (path == null) {
        console.warn("Path was not provided upon construction of new Rehab()");
        return;
      }
      this.dep = deppy.create();
      sources = this.getSourceFiles(path);
      sourceFolder = path.getDir();
      this.sources = [];
      this.unresolved = [];
      this.processDependencies(sources, sourceFolder);
      while (this.unresolved.length) {
        toResolve = this.unresolved[0];
        this.processDependencies([p.basename(toResolve)], p.dirname(toResolve));
      }
      this.dep(this.REQ_MAIN_NODE, this.sources);
    }

    Rehab.prototype.listFiles = function() {
      return this.dep.resolve(this.REQ_MAIN_NODE).filter((function(_this) {
        return function(elem) {
          return elem !== _this.REQ_MAIN_NODE;
        };
      })(this));
    };

    Rehab.prototype.compile = function() {
      var code, coffee, err, source, _i, _len, _ref;
      coffee = require('coffee-script');
      code = "";
      _ref = this.listFiles();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        source = _ref[_i];
        try {
          code += '\n' + fs.readFileSync(source);
        } catch (_error) {
          err = _error;
          if (err.code === 'ENOENT') {
            return;
          } else {
            throw err;
          }
        }
      }
      return coffee.compile(code);
    };

    Rehab.prototype.REQ_MAIN_NODE = "__MAIN__";

    Rehab.prototype.REQ_LINE_REGEX = /^\#_require\s+(.+(?=coffee)coffee)/;

    Rehab.prototype.process = function(filePath) {
      return new Rehab(filePath).listFiles();
    };

    Rehab.prototype.processDependencies = function(sources, folder) {
      var depend, deps, filePath, fl, _i, _j, _len, _len1, _results;
      _results = [];
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        fl = sources[_i];
        filePath = p.resolve(folder, fl);
        if (__indexOf.call(this.sources, filePath) >= 0) {
          continue;
        }
        deps = this.parseFile(fl, folder);
        this.dep(filePath, deps);
        this.sources.push(filePath);
        for (_j = 0, _len1 = deps.length; _j < _len1; _j++) {
          depend = deps[_j];
          if ((__indexOf.call(this.sources, depend) < 0) && (__indexOf.call(this.unresolved, depend) < 0)) {
            this.unresolved.push(depend);
          }
        }
        _results.push(this.unresolved = this.unresolved.filter((function(_this) {
          return function(elem) {
            return __indexOf.call(_this.sources, elem) < 0;
          };
        })(this)));
      }
      return _results;
    };

    Rehab.prototype.normalizeCoffeeFile = function(filename) {
      if (!filename.endsWith('.coffee')) {
        filename = filename + '.coffee';
      }
      return filename;
    };

    Rehab.prototype.getSourceFiles = function(filePath) {
      var file, files, _i, _len, _results;
      if (filePath.endsWith('.coffee')) {
        return [p.basename(filePath)];
      } else {
        files = wrench.readdirSyncRecursive(filePath);
        _results = [];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          if (file.endsWith('.coffee')) {
            _results.push(file);
          }
        }
        return _results;
      }
    };

    Rehab.prototype.parseFile = function(file, folder) {
      var content, filePath, line, reqFile, reqs, requiredFile, _i, _len, _ref;
      file = this.normalizeCoffeeFile(file);
      filePath = p.resolve(folder, file);
      reqs = [];
      content = fs.readFileSync(filePath, 'utf8');
      _ref = content.split(/\s*[\n\r]+\s*/);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (requiredFile = line.match(this.REQ_LINE_REGEX)) {
          reqFile = p.resolve(folder + 'relchild', requiredFile[1]);
          reqs.push(reqFile);
        }
      }
      return reqs;
    };

    Rehab.prototype.parseRequiredFile = function(folder, basename) {
      var content, filePath, line, reqs, requiredFile, _i, _len, _ref;
      filePath = p.join(folder, basename);
      reqs = [this.REQ_MAIN_NODE];
      content = fs.readFileSync(filePath, 'utf8');
      _ref = content.split(/\s*[\n\r]+\s*/);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        if (requiredFile = this.parseRequiredLine(line)) {
          reqs.push([requiredFile]);
        }
      }
      return this.dep(filePath, reqs);
    };

    return Rehab;

  })();

}).call(this);
